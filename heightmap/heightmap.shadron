// first try for a heightmap
#include <perlin>
#include <worley>
#include <math_constants>
#include <affine_transform>
#include <lighting>
#include <heightmap>

//heightmap resolution
parameter int SIDE = 1024: logrange(1,8192);
//scale of height  effects how strong the effect is
parameter float heightScale = 1.0;
//rotation
parameter vec2 rotation = vec2(0.0,0.5) : range(-PI,+PI);
// distance between camara and heightmap
parameter float distance = 2.0 : range(16.0);
// FOV
parameter float FOV = 0.5*PI : range(0.0, PI);
// min and max drawdistance
const float NEAR = 1.0/512, FAR = 512.0;
//incoming light
const vec3 lightDirection = vec3(-1.0,-1.0,-1.0);
// Size of the image
const int SIZE = 4096;
// Number of iteration in the fractal noise computation
const int FRACTAL_STEPS = 3;
// Scale of the noise
const float scale_fractal = 20.0;

//input texture
image HeightMap = file();
//if you want to use a diffrent texturefor color change this
#define Texture FractalWorleyNoise

// Basic Worley noise, projected as F2-F1 (second lowest distance - lowest distance to Voronoi site)
glsl float basicWorley(vec2 pos) {
    vec2 w = worleyNoise(scale_fractal*pos);
    return w.y-w.x;
}

// A template that samples FN at different scales and adds them together - the fractal noise
template <FN, STEPS>
glsl float fractal(vec2 pos) {
    float total = 0.0;
    float factor = 1.0;
    for (int i = 0; i < STEPS; ++i) {
        factor *= 0.5;
        total += factor*FN(pos-vec2(i));
        pos *= 2.0;
    }
    return total;
}

//passing fragment data from vertex shader to the fragment shader
glsl struct FragmentData
{
	vec2 texCoord;
	vec3 normal;
};

//the height function
glsl float heightFn(vec2 pos)
{
	vec3 s = texture(HeightMap, pos).rgb;
	return heightScale/3.0*(s.r+s.g+s.b);
}

//the vertex shader
glsl vec4 vertexShader(out FragmentData f,int index)
{
	// Acquire vertex coordinate, texture coordinate, and normal vector
	vec3 coord = heightmapCoord<heightFn, SIDE, SIDE>(index);
	f.texCoord = heightmapTexCoord<heightFn,SIDE,SIDE>(index);
	f.normal = heightmapNormal<heightFn,SIDE,SIDE>(index);

    // Transform coordinate
    coord = translate(coord, vec3(-0.5, -0.5, 0.0));
    coord = rotateZ(coord, rotation.x);
    coord = rotateX(coord, -0.5*PI+rotation.y);
    coord = translate(coord, vec3(0.0, 0.0, -distance));

    // Transform normal
    f.normal = rotateZ(f.normal, rotation.x);
    f.normal = rotateX(f.normal, -0.5*PI+rotation.y);

    // Perspective projection
    return projectPerspectiveHFOV(coord, FOV, NEAR, FAR);
}
image FractalWorleyNoise = glsl(fractal<basicWorley, FRACTAL_STEPS>, ivec2(SIZE));
image BasicWorleyNoise = glsl(basicWorley, ivec2(SIZE));
//fragment shader
glsl vec4 fragmentShader(in FragmentData f)
{
	float lightness = mix(1.0,diffuseLight(lightDirection,f.normal),0.75);
	return lightness*texture(Texture, f.texCoord);
}
//heightmap model defenition
model image Terrain :
	fragment_data(FragmentData),
	vertex(vertexShader, triangles, HEIGHTMAP_VERTEX_COUNT(SIDE,SIDE)),
	fragment(fragmentShader),
	multisample(4),
	dimensions(640,480);

	//heightmap model defenition
 model Terrainmod :
	fragment_data(FragmentData),
	vertex(vertexShader, triangles, HEIGHTMAP_VERTEX_COUNT(SIDE,SIDE)),
	fragment(fragmentShader);
	//multisample(4);
	
	export png(Terrain,"terrain,png");